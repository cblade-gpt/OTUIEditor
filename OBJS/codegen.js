/* OTUI Editor is licensed for **personal, non-commercial use only**.
Commercial use, resale, or closed-source redistribution is strictly prohibited.
Contributions are welcome via pull requests. */

// Helper function to get original property name from camelCase dataset key
function getOriginalPropertyName(widget, camelKey) {
    if (!widget.dataset._keyMap) {
        // No mapping stored, assume camelKey is already the original (for backwards compatibility)
        return camelKey;
    }
    try {
        const keyMap = JSON.parse(widget.dataset._keyMap);
        return keyMap[camelKey] || camelKey;
    } catch (e) {
        return camelKey;
    }
}

// Helper function to convert camelCase to hyphenated (for dataset lookup)
function toCamelCase(str) {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

// Helper function to get value from dataset (handles camelCase conversion)
function getDatasetValue(widget, key) {
    const camelKey = toCamelCase(key);
    return widget.dataset[camelKey];
}

function formatTranslationValue(value) {
    if (!value) return '';
    const trimmed = value.trim();
    if (/^tr\s*\(/i.test(trimmed)) {
        return trimmed;
    }
    if ((trimmed.startsWith('"') && trimmed.endsWith('"')) ||
        (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
        return `tr(${trimmed})`;
    }
    const escaped = value.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
    return `tr('${escaped}')`;
}

function generateOTUICode() {
    // SECURE: All generation logic is server-side only
    if (window.APIClient && window.APIClient.generateOTUICode) {
        return window.APIClient.generateOTUICode();
    }
    throw new Error('generateOTUICode: API server required. Please start the server.');
}

function generateLuaCode() {
    const moduleName = document.getElementById('moduleName')?.value || 'main';
    const moduleTitle = document.getElementById('moduleTitle')?.value || 'My Module';
    const uiFileName = `${moduleName}.otui`;
    
    // Helper function to sanitize Lua identifiers (ensure valid variable/function names)
    const sanitizeLuaIdentifier = (str) => {
        if (!str) return 'widget';
        // Replace invalid characters with underscore, ensure it starts with a letter
        let sanitized = str.replace(/[^a-zA-Z0-9_]/g, '_');
        // Ensure it starts with a letter or underscore
        if (/^[0-9]/.test(sanitized)) {
            sanitized = '_' + sanitized;
        }
        // Ensure it's not empty
        if (!sanitized || sanitized.length === 0) {
            sanitized = 'widget';
        }
        return sanitized;
    };
    
    // Get the root widget ID (first widget in editor, use its actual ID)
    const roots = [...document.querySelectorAll('#editorContent > .widget')];
    const rootWidget = roots[0]; // First widget becomes the root
    const rootWidgetId = rootWidget ? sanitizeLuaIdentifier(rootWidget.id) : sanitizeLuaIdentifier(moduleName);
    
    // Collect all widgets that have events
    const widgetRefs = new Map();
    
    function collectWidgets(widget) {
        const type = widget.dataset.type;
        const id = widget.id;
        const def = OTUI_WIDGETS[type];
        if (!def) return;
        
        const isRoot = widget.parentElement && widget.parentElement.id === 'editorContent';
        const hasEvents = Object.keys(def.events).length > 0;
        
        // Collect root widget (always needed for Lua reference) and widgets with events
        if (isRoot || hasEvents) {
            // Sanitize the ID to ensure it's a valid Lua identifier
            const sanitizedId = sanitizeLuaIdentifier(id);
            widgetRefs.set(sanitizedId, {
                id: sanitizedId,
                originalId: id, // Keep original ID for OTUI file lookup
                type: type,
                def: def,
                widget: widget,
                isRoot: isRoot
            });
        }
        
        // Process children recursively
        const children = [...widget.children].filter(c => c.classList.contains('widget'));
        children.forEach(child => {
            collectWidgets(child);
        });
    }
    
    // Collect all widgets
    roots.forEach(root => {
        collectWidgets(root);
    });
    
    // Start generating Lua code following OTCv8 module structure
    let code = `-- Generated by OTUI Builder 0.1.1 Beta\n`;
    code += `-- OTCv8 Compatible Module\n`;
    code += `-- Module: ${moduleTitle}\n\n`;
    
    // Module-level widget variables
    code += `local ${rootWidgetId} = nil\n`;
    
    // Declare all widget variables at module level (root widget and widgets with events)
    widgetRefs.forEach((widgetData, id) => {
        if (!widgetData.isRoot) {
            code += `local ${id} = nil\n`;
        }
    });
    code += `\n`;
    
    // Generate event handler functions (defined before init)
    if (widgetRefs.size > 0) {
        code += `-- Event handler functions\n`;
        widgetRefs.forEach((widgetData, id) => {
            const { type, def } = widgetData;
            
            if (Object.keys(def.events).length > 0) {
                Object.entries(def.events).forEach(([event, sig]) => {
                    // Extract parameters from signature
                    const params = sig.replace(/^function\s*\(|\)\s*$|function\s*/g, '')
                        .split(',')
                        .map(p => p.trim())
                        .filter(p => p);
                    
                    // Generate handler function name
                    const handlerName = `${id}_${event}`;
                    
                    code += `local function ${handlerName}(${params.join(', ')})\n`;
                    code += `  -- TODO: Implement ${event} handler for ${type} '${id}'\n`;
                    if (params.length > 0) {
                        code += `  -- Parameters: ${params.join(', ')}\n`;
                    }
                    code += `end\n\n`;
                });
            }
        });
    }
    
    // Generate init() function following OTCv8 pattern
    code += `-- Initialize module\n`;
    code += `function init()\n`;
    code += `  -- Load the UI file (module context automatically finds it)\n`;
    code += `  ${rootWidgetId} = g_ui.loadUI('${moduleName}', rootWidget)\n`;
    code += `  if not ${rootWidgetId} then\n`;
    code += `    g_logger.error("${moduleTitle}: Failed to load UI from '${moduleName}.otui'")\n`;
    code += `    return false\n`;
    code += `  end\n\n`;
    
    // Get all child widgets using recursiveGetChildById from the loaded root widget
    if (widgetRefs.size > 0) {
        // Separate root widget from child widgets
        const rootWidgetRef = Array.from(widgetRefs.values()).find(w => w.isRoot);
        const childWidgetRefs = Array.from(widgetRefs.values()).filter(w => !w.isRoot);
        
        // Get child widget references
        if (childWidgetRefs.length > 0) {
            code += `  -- Get widget references\n`;
            childWidgetRefs.forEach((widgetData) => {
                const { id, originalId } = widgetData;
                // Use originalId for lookup (from OTUI file), but sanitized id for variable name
                const lookupId = originalId || id;
                code += `  ${id} = ${rootWidgetId}:recursiveGetChildById('${lookupId}')\n`;
                code += `  if not ${id} then\n`;
                code += `    g_logger.warning("${moduleTitle}: Widget '${lookupId}' not found in UI")\n`;
                code += `  end\n`;
            });
            code += `\n`;
        }
        
        // Connect event handlers using OTCv8's connect() function
        code += `  -- Connect event handlers\n`;
        widgetRefs.forEach((widgetData) => {
            const { id, type, def, isRoot } = widgetData;
            const widgetVar = isRoot ? rootWidgetId : id;
            
            if (Object.keys(def.events).length > 0) {
                code += `  if ${widgetVar} then\n`;
                code += `    connect(${widgetVar}, {\n`;
                
                const eventEntries = Object.entries(def.events);
                eventEntries.forEach(([event, sig], index) => {
                    const handlerName = `${id}_${event}`;
                    const isLast = index === eventEntries.length - 1;
                    code += `      ${event} = ${handlerName}${isLast ? '' : ','}\n`;
                });
                
                code += `    })\n`;
                code += `  end\n`;
            }
        });
        code += `\n`;
    }
    
    code += `  return true\n`;
    code += `end\n\n`;
    
    // Generate helper functions to show/hide/toggle the root widget
    code += `-- Show the root widget\n`;
    code += `function show()\n`;
    code += `  if ${rootWidgetId} then\n`;
    code += `    ${rootWidgetId}:show()\n`;
    if (rootWidget && rootWidget.dataset.type === 'UIWindow') {
        code += `    ${rootWidgetId}:raise()\n`;
        code += `    ${rootWidgetId}:focus()\n`;
    }
    code += `  end\n`;
    code += `end\n\n`;
    
    code += `-- Hide the root widget\n`;
    code += `function hide()\n`;
    code += `  if ${rootWidgetId} then\n`;
    code += `    ${rootWidgetId}:hide()\n`;
    code += `  end\n`;
    code += `end\n\n`;
    
    code += `-- Toggle root widget visibility\n`;
    code += `function toggle()\n`;
    code += `  if ${rootWidgetId} then\n`;
    code += `    if ${rootWidgetId}:isVisible() then\n`;
    code += `      hide()\n`;
    code += `    else\n`;
    code += `      show()\n`;
    code += `    end\n`;
    code += `  end\n`;
    code += `end\n\n`;
    
    // Generate terminate() function
    code += `-- Cleanup module\n`;
    code += `function terminate()\n`;
    if (widgetRefs.size > 0) {
        code += `  -- Disconnect event handlers\n`;
        widgetRefs.forEach((widgetData) => {
            const { id, def, isRoot } = widgetData;
            const widgetVar = isRoot ? rootWidgetId : id;
            
            if (Object.keys(def.events).length > 0) {
                code += `  if ${widgetVar} then\n`;
                code += `    disconnect(${widgetVar})\n`;
                code += `  end\n`;
            }
        });
        code += `\n`;
        code += `  -- Cleanup widget references\n`;
        code += `  if ${rootWidgetId} then\n`;
        code += `    ${rootWidgetId}:destroy()\n`;
        code += `  end\n`;
        code += `  ${rootWidgetId} = nil\n`;
        widgetRefs.forEach((widgetData, id) => {
            if (!widgetData.isRoot) {
                code += `  ${id} = nil\n`;
            }
        });
    } else {
        code += `  if ${rootWidgetId} then\n`;
        code += `    ${rootWidgetId}:destroy()\n`;
        code += `  end\n`;
        code += `  ${rootWidgetId} = nil\n`;
    }
    code += `end\n`;
    
    return code.trim();
}

function generateOTMODCode() {
    const moduleName = document.getElementById('moduleName')?.value || 'main';
    const moduleTitle = document.getElementById('moduleTitle')?.value || 'My Module';
    const moduleDescription = document.getElementById('moduleDescription')?.value || '';
    const moduleAuthor = document.getElementById('moduleAuthor')?.value || '';
    const moduleWebsite = document.getElementById('moduleWebsite')?.value || '';
    const moduleSandboxed = document.getElementById('moduleSandboxed')?.checked !== false; // Default true
    const moduleAutoload = document.getElementById('moduleAutoload')?.checked !== false; // Default true
    
    // OTML format requires proper indentation and Module tag
    let code = 'Module\n';
    
    // Name (required)
    code += `  name: ${moduleName}\n`;
    
    // Description (optional, use title as fallback)
    code += `  description: ${moduleDescription || moduleTitle}\n`;
    
    // Author (optional, only include if provided)
    if (moduleAuthor) {
        code += `  author: ${moduleAuthor}\n`;
    }
    
    // Website (optional, only include if provided)
    if (moduleWebsite) {
        code += `  website: ${moduleWebsite}\n`;
    }
    
    // Sandboxed (default: true)
    code += `  sandboxed: ${moduleSandboxed ? 'true' : 'false'}\n`;
    
    // Autoload (default: true)
    code += `  autoload: ${moduleAutoload ? 'true' : 'false'}\n`;
    
    // Scripts array (list format)
    code += `  scripts:\n`;
    code += `    - ${moduleName}.lua\n`;
    
    // Event handlers
    code += `  @onLoad: init()\n`;
    code += `  @onUnload: terminate()\n`;
    
    return code.trim();
}

async function updateCodeDisplay() {
    // Check if there are widgets before trying to generate code
    const editorContent = document.getElementById('editorContent');
    const widgetCount = editorContent ? editorContent.querySelectorAll('.widget').length : 0;
    
    if (widgetCount === 0) {
        // No widgets - set empty code
        const otuiEl = document.querySelector('#codeModal #otuiCode code');
        const luaEl = document.querySelector('#codeModal #luaCode code');
        const otmodEl = document.querySelector('#codeModal #otmodCode code');
        
        if (otuiEl) otuiEl.textContent = '// No widgets on canvas';
        if (luaEl) luaEl.textContent = '-- No widgets on canvas';
        if (otmodEl) otmodEl.textContent = '// No widgets on canvas';
        return;
    }
    
    // Generate code - generateOTUICode now returns a promise
    let otuiCode;
    try {
        otuiCode = await generateOTUICode();
        // Ensure it's a string
        if (typeof otuiCode !== 'string') {
            console.warn('generateOTUICode returned non-string, converting:', typeof otuiCode);
            otuiCode = String(otuiCode || '');
        }
    } catch (error) {
        // Check if it's a connection error
        const isConnectionError = error.message.includes('Failed to fetch') || 
                                  error.message.includes('ERR_CONNECTION_REFUSED') ||
                                  error.message.includes('NetworkError');
        
        if (isConnectionError) {
            otuiCode = `// API server is not available.\n// Please ensure the server is running at ${window.APIClient?.API_BASE_URL || 'http://localhost:3000/api'}\n// Error: ${error.message}`;
        } else {
            otuiCode = `// Error generating code: ${error.message}`;
        }
        // Only log to console, don't spam errors
        console.warn('Failed to generate OTUI code:', error.message);
    }
    
    const luaCode = generateLuaCode();
    const otmodCode = generateOTMODCode();
    
    // Debug logging
    console.log('=== CODE GENERATION DEBUG ===');
    console.log('OTUI Code length:', otuiCode.length);
    console.log('OTUI Code preview:', otuiCode.substring(0, 200));
    console.log('Full OTUI Code:', otuiCode);
    
    // Update code elements in modal
    const otuiEl = document.querySelector('#codeModal #otuiCode code');
    const luaEl = document.querySelector('#codeModal #luaCode code');
    const otmodEl = document.querySelector('#codeModal #otmodCode code');
    
    console.log('OTUI element found:', !!otuiEl);
    console.log('LUA element found:', !!luaEl);
    console.log('OTMOD element found:', !!otmodEl);
    
    if (otuiEl) {
        otuiEl.textContent = otuiCode;
        console.log('OTUI code set, element content length:', otuiEl.textContent.length);
    } else {
        console.error('OTUI code element not found!');
    }
    
    if (luaEl) {
        luaEl.textContent = luaCode;
    }
    
    if (otmodEl) {
        otmodEl.textContent = otmodCode;
    }
    
    // Re-highlight if modal is visible
    const codeModal = document.getElementById('codeModal');
    if (codeModal && codeModal.style.display !== 'none') {
        if (typeof Prism !== 'undefined') {
            // Highlight all code blocks in the modal
            codeModal.querySelectorAll('code').forEach(codeEl => {
                Prism.highlightElement(codeEl);
            });
        }
    }
}

function showCodeModal() {
    const modal = document.getElementById('codeModal');
    if (!modal) return;
    
    // Update code before showing
    updateCodeDisplay();
    
    // Show modal
    modal.style.display = 'flex';
    
    // Reset and show active tab
    const allTabs = modal.querySelectorAll('.code-tab');
    const allBlocks = modal.querySelectorAll('.code-block');
    
    // Hide all blocks first
    allBlocks.forEach(block => {
        block.style.display = 'none';
        block.classList.remove('active');
    });
    
    // Find active tab or default to OTUI
    let activeTab = modal.querySelector('.code-tab.active');
    if (!activeTab) {
        activeTab = modal.querySelector('.code-tab[data-tab="otui"]');
        if (activeTab) {
            allTabs.forEach(t => t.classList.remove('active'));
            activeTab.classList.add('active');
        }
    }
    
    // Show corresponding code block
    if (activeTab) {
        const tabName = activeTab.dataset.tab;
        const codeBlock = modal.querySelector(`#${tabName}Code`);
        if (codeBlock) {
            codeBlock.style.display = 'block';
            codeBlock.classList.add('active');
        }
    }
    
    // Highlight code after a short delay to ensure DOM is ready
    setTimeout(() => {
        if (typeof Prism !== 'undefined') {
            const visibleBlock = modal.querySelector('.code-block.active');
            if (visibleBlock) {
                const codeElement = visibleBlock.querySelector('code');
                if (codeElement) {
                    Prism.highlightElement(codeElement);
                }
            }
        }
    }, 150);
}

